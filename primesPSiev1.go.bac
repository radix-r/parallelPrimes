/*

<execution time>  <total number of
primes found>  <sum of all primes found>
< top ten maximum primes, listed in order from lowest to highest>

*/
package main

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

var initUpTo = 100


type Channels struct{
	lists chan []int
	done chan bool
	sums chan uint64
	count chan int

}

func main(){



	var numTh int = 8
	var upTo int = 100000000

	// benchmark
	/*
	var primes = []int{}

	start := time.Now()
	// simple single thread brute force approach
	for i := 3; i < upTo; i+=2{
		if SimplePrimeCheck(i,0,i){
			primes = append(primes,i)
		}
	}

	primesStr := IntSliceToString(primes)

	err:=ioutil.WriteFile("primes.txt",[]byte(primesStr),0)

	if err != nil{
		log.Fatal(err)
	}

	elapsed := time.Since(start)

	log.Printf("Single thread brute force time: %s",elapsed)
	*/
	start := time.Now()
	GoPrime(numTh, upTo)
	elapsed := time.Since(start)

	log.Printf("Multi thread sieve time: %s",elapsed)
}

/*
using both probabilistic and simple deterministic checks, quickly (hopefully) determines if a number is prime
*/
func CheckPrime(n int)bool{

	return SimplePrimeCheck(n, 0, n)
	/*
	//res := SimplePrimeCheck(n, 0, initUpTo)
	res:= true
	if res {
		// using Baillie–PSW primality test https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW_primality_test
		res = ProbPrimeCheck(n)

		if res{
			// check found primes with simplePrimeCheck
			res = SimplePrimeCheck(n, 0, n)
		}
	}
	return res
	*/

}

// Copy the values from channel 'in' to channel 'out',
// removing those divisible by 'prime'.
// from https://golang.org/doc/play/sieve.go
func Filter(in <-chan int, out chan<- int, thSlotsReceive <-chan bool, prime int) {
	//thSlotsSend<-true // block a thread slot
	fmt.Printf("Filtering numbers divisable by %d...\n",prime)

	i := 0
	for i != -1{
		i = <-in // Receive value from 'in'.
		if i%prime != 0 {
			out <- i // Send 'i' to 'out'.
		}
	}
	<-thSlotsReceive // free thread slot
	fmt.Printf("Finished Filtering numbers divisable by %d\n",prime)
}

// Send the sequence 2, 3, 4, ... to channel 'ch'.
// from https://golang.org/doc/play/sieve.go
func Generate(ch chan<- int, thSlotsSend chan<-bool, thSlotsReceive <-chan bool, upTo int) {
	//thSlotsSend<-true
	fmt.Printf("Generating numbers up to %d...\n", upTo)
	for i := 2; i<= upTo ; i++ {
		ch <- i // Send 'i' to channel 'ch'.
	}
	ch <- -1 // -1 to signal end
	<-thSlotsReceive
	fmt.Printf("Finished generating numbers\n")
}

/*nums some helper functions and merges the lists of primes*/
func GoPrime(numTh int, upTo int) {

	primesInfo ,err := os.OpenFile("primes.txt", os.O_RDWR,0666)

	if err != nil{
		log.Fatal(err)
	}
	//clear file and set cursor to beginning
	primesInfo.Truncate(0)
	primesInfo.Seek(0,0)

	// The prime sieve: Daisy-chain Filter processes.

	var primes []int
	var prime int
	ch := make(chan int, numTh) // Create a new channel.
	thSlots := make(chan bool, numTh) // Create numTh slots for threads

	thSlots<-true
	go Generate(ch,thSlots,thSlots, upTo)      // Launch Generate goroutine.

	for i := 0; ; i++ { // when do I stop
		prime = <-ch
		if prime == -1{
			break
		}
		primes=append(primes, prime)
		ch1 := make(chan int,numTh)
		thSlots<-true
		go Filter(ch, ch1,thSlots, prime)
		ch = ch1
	}

	n:=10

	finalSum:= sumSlice(primes)
	finalCount:= len(primes)
	nLargest := []int{0,1}//[0,1]//primes[finalCount-n:]

	/*
	// create a buffer channel with numTh slots. threads will report their list of primes on completion
	channels := Channels{}
	channels.lists = make(chan []int, numTh)
	channels.done = make(chan bool, numTh)
	channels.sums = make(chan uint64, numTh)
	channels.count = make(chan int, numTh)
	// include 2, the first prime
	var finalSum uint64 = 2
	finalCount := 1




	// give each thread a start value then check <start value>+ k*numTh values
	//for each thread call ParallelPrimes
	for i:=0;i<numTh;i++{
		// start with the first numTh odds after 2. 3,5,7, ...ect

		go ParallelPrimes(channels, i, numTh, upTo)
	}


	// make sure each thread is done
	for i:=0;i<numTh;i++{
		<-channels.done
		finalSum += <-channels.sums
		finalCount += <-channels.count
	}


	*/



	// write info to file
	primesInfo.WriteString(fmt.Sprintf("Primes up to: %d\n",upTo) )
	primesInfo.WriteString(fmt.Sprintf("Sum: %d\n",finalSum) )
	primesInfo.WriteString(fmt.Sprintf("Count: %d\n",finalCount) )
	primesInfo.WriteString(fmt.Sprintf("%d Largest:\n",n) )
	for _, num := range nLargest{
		primesInfo.WriteString(fmt.Sprintf("\t%d\n",num) )
	}





}
/*creates the threads */
func ParallelPrimes(channels Channels, start int, numTh int, upTo int){
	var primes []int

	// starting thread start
	fmt.Printf("Starting thread %d\n", start)

	startTime := time.Now()

	jumpAmt := numTh
	// if even jump amt is 2*numTh
	if numTh%2 == 0{
		jumpAmt = 2*numTh
	}


	for i:=3+start*2;i<upTo;i+=jumpAmt{
		if CheckPrime(i){
			primes = append(primes,i)
		}
	}

	var sum uint64 = sumSlice(primes)
	elapsed := time.Since(startTime)
	fmt.Printf("Finished thread %d in %s\n", start, elapsed)
	fmt.Printf("\tNum Found: %d\n",len(primes))
	if len(primes)!=0{
		fmt.Printf("\tMax: %d\n",primes[len(primes)-1])
	}

	channels.count <- len(primes)
	channels.sums <- sum
	channels.lists<-primes
	channels.done<-true


}

/**/
func ProbPrimeCheck(n int) bool{

	// using Baillie–PSW primality test https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW_primality_test

	// let n be an odd positive int that we wish to check for primality

	// trial division of small primes upto 100? (use simplePrimeCheck alg)

	// base 2 strong probable prime test. If n is not a strong probable prime base 2, then n is composite; quit. https://en.wikipedia.org/wiki/Strong_pseudoprime

	// Find the first D in the sequence 5, −7, 9, −11, 13, −15, ... [(5+2i)*-1^i, i starts at 0] for which the Jacobi symbol (D/n) is −1. Set P = 1 and Q = (1 − D) / 4.

	// Perform a strong Lucas probable prime test on n using parameters D, P, and Q. If n is not a strong Lucas probable prime, then n is composite. Otherwise, n is almost certainly prime.

	return true
}

/*
returns true if int n is prime, false otherwise
takes a start and max value to check
*/
func SimplePrimeCheck(n int, start int, max int)bool{
	if n <= 3{
		return n > 1
	}else if n % 2 == 0 || n % 3 == 0{
		return false
	}else{

		i := start
		if i < 5{
			i = 5
		}

		for i * i <= n && i <= max{
			if n % i == 0 || n % (i + 2) == 0{
				return false
			}

			i = i + 6
		}
		return true
	}
}


/*takes an int slice and returns a uint64*/
func sumSlice(nums []int)uint64{
	var sum uint64 = 0
	for _, num :=range nums{
		sum += uint64(num)
	}
	return sum
}
/*
from: https://www.dotnetperls.com/convert-slice-string-go
*/
func IntSliceToString(nums []int)string{
	var valuesText []string

	// Create a string slice using strconv.Itoa.
	// ... Append strings to it.
	for i := range nums {
		number := nums[i]
		text := strconv.Itoa(number)
		valuesText = append(valuesText, text)
	}

	// Join our string slice.
	result := strings.Join(valuesText, " ")
	return result
}
